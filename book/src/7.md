# 7. 生成机器码

完成上一节留空的 compile 方法。

首先初始化汇编器。整个 brainfuck 程序编译为一个大函数，函数起始地址就是最开始的偏移。

loops 作为栈，用来存放动态标签，指引跳转。

```rust,noplaypen
{{#include ../../src/bfjit.rs:102:106}}
```

sysv64 调用约定规定 rdi, rsi, rdx, rcx 存放前四个整数参数，rax 存放返回值。

在注释中约定各个寄存器存放的参数，虚拟机调用裸函数时将把参数放入寄存器。

```rust,noplaypen
{{#include ../../src/bfjit.rs:108:111}}
```

程序开始，首先把 rax 压栈。x86-64-psABI 规定参数区域的结尾按16字节对齐。函数开始时返回地址压栈，此时 栈指针+8 是 16 的倍数，因此再把 rax 压栈，使栈指针对齐，以便之后的函数调用，rax 的内容没有意义。

把寄存器中的各参数存入非易失性寄存器，调用其他函数时参数寄存器的值可能丢失。rbp, rbx, r12 ~ r15 是非易失性寄存器。

```rust,noplaypen
{{#include ../../src/bfjit.rs:113:119}}
```

每个 IR 依次映射到汇编。

指针移动，需要检查算术溢出和数组边界溢出，出错即跳转到全局标签所指的错误处理区域。

```rust,noplaypen
{{#include ../../src/bfjit.rs:121:135}}
```

单个字节的算术加减，允许溢出。

```rust,noplaypen
{{#include ../../src/bfjit.rs:136:141}}
```

IO 操作。首先保存当前数据指针寄存器，将虚拟机函数所需的各参数和函数地址放入寄存器，调用函数。

如果函数返回的不是空指针，说明出错，应该跳转到IO错误处理区域。

最后恢复数据指针寄存器。

```rust,noplaypen
{{#include ../../src/bfjit.rs:142:165}}
```

跳转指令。利用 dynasm 提供的 api， 创建两个动态标签，分别生成跳转汇编。由于编译到 IR 时已经验证过跳转指令的对应关系，这里的栈可以直接弹出。

```rust,noplaypen
{{#include ../../src/bfjit.rs:162:182}}
```

正常退出函数时应该返回空指针，表示没有错误。

溢出时生成一个溢出错误，IO错误时错误指针已经存入 rax，无需处理。

最后退栈，与函数开始时的压栈对应，维持栈平衡。

```rust,noplaypen
{{#include ../../src/bfjit.rs:184:195}}
```

完成汇编，取出可执行缓冲区，返回。

```rust,noplaypen
{{#include ../../src/bfjit.rs:197:200}}
```

